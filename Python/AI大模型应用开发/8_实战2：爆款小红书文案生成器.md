---
title: 实战2：爆款小红书文案生成器
tags:
  - Python
categories:
  - Python
---



## 一、项目介绍

### 1、核心功能

- 帮助用户生成适用于小红书平台的爆款文案，包括待选标题和正文内容，支持用户通过自有 API 密钥调用 AI 模型。

### 2、界面设计

1. **侧边栏**
   - 可收起 / 展开，支持用户输入 API 密钥（避免消耗开发者 token）。
   - 附 OpenAI 官方 API 密钥获取链接，方便用户跳转查看获取方法。
2. **主页面**
   - 设计简洁，包含：一个输入框（用于用户填写文案主题）、一个 “开始写作” 按钮。

### 3、用户交互流程

1. **输入验证**
   - 若用户未提供 API 密钥却点击 “开始写作”：提示用户输入密钥。
   - 若用户提供了 API 密钥但未填写主题：提示用户补充主题。
2. **生成过程**
   - 信息完整后点击按钮，触发 AI 生成流程，此时显示加载组件（告知用户 AI 正在生成内容）。
3. **结果展示**
   - 生成完成后，结果在分隔线下方展示，分为两列：
     - 左列：AI 生成的 5 个待选标题。
     - 右列：AI 生成的文案正文。

## 二、创建AI请求

### 1、项目初始化

1. 创建项目与依赖安装

   - 新建项目文件夹`xiaohongshu-generator`，目录下创建`requirements.txt`文件夹，粘贴以下内容。

     ~~~txt
     aiohttp==3.8.6
     aiosignal==1.3.1
     altair==5.1.2
     annotated-types==0.6.0
     anyio==3.7.1
     appnope==0.1.3
     argon2-cffi==23.1.0
     argon2-cffi-bindings==21.2.0
     arrow==1.3.0
     astroid==3.0.1
     asttokens==2.4.1
     async-lru==2.0.4
     async-timeout==4.0.3
     attrs==23.1.0
     Babel==2.13.1
     beautifulsoup4==4.12.2
     bleach==6.1.0
     blinker==1.7.0
     cachetools==5.3.2
     Cerberus==1.3.5
     certifi==2023.7.22
     cffi==1.15.1
     charset-normalizer==3.3.2
     click==8.1.7
     comm==0.2.0
     contourpy==1.2.0
     cycler==0.12.1
     dataclasses-json==0.6.2
     debugpy==1.8.0
     decorator==5.1.1
     defusedxml==0.7.1
     dill==0.3.7
     distlib==0.3.7
     distro==1.8.0
     docopt==0.6.2
     exceptiongroup==1.1.3
     executing==2.0.1
     fastjsonschema==2.19.0
     fonttools==4.46.0
     fqdn==1.5.1
     frozenlist==1.4.0
     gitdb==4.0.11
     GitPython==3.1.40
     greenlet==3.0.1
     h11==0.14.0
     httpcore==1.0.2
     httpx==0.25.1
     idna==3.4
     importlib-metadata==6.8.0
     ipykernel==6.27.1
     ipython==8.18.1
     ipywidgets==8.1.1
     isoduration==20.11.0
     isort==5.13.0
     jedi==0.19.1
     Jinja2==3.1.2
     json5==0.9.14
     jsonpatch==1.33
     jsonpath-ng==1.6.1
     jsonpointer==2.4
     jsonschema==4.19.2
     jsonschema-specifications==2023.7.1
     jupyter==1.0.0
     jupyter-console==6.6.3
     jupyter-events==0.9.0
     jupyter-lsp==2.2.1
     jupyter_ai_magics==2.10.0
     jupyter_client==8.6.0
     jupyter_core==5.5.0
     jupyter_server==2.12.1
     jupyter_server_terminals==0.4.4
     jupyterlab==4.0.9
     jupyterlab-widgets==3.0.9
     jupyterlab_pygments==0.3.0
     jupyterlab_server==2.25.2
     kiwisolver==1.4.5
     langchain==0.1.9
     langchain-community==0.0.24
     langchain-core==0.1.26
     langchain-openai==0.0.7
     langsmith==0.1.9
     markdown-it-py==3.0.0
     MarkupSafe==2.1.3
     marshmallow==3.20.1
     matplotlib==3.8.2
     matplotlib-inline==0.1.6
     mccabe==0.7.0
     mdurl==0.1.2
     mistune==3.0.2
     multidict==6.0.4
     mypy-extensions==1.0.0
     nbclient==0.9.0
     nbconvert==7.12.0
     nbformat==5.9.2
     nest-asyncio==1.5.8
     notebook==7.0.6
     notebook_shim==0.2.3
     numpy==1.26.2
     openai==1.12.0
     orjson==3.9.15
     overrides==7.4.0
     packaging==23.2
     pandas==2.1.3
     pandocfilters==1.5.0
     parso==0.8.3
     patsy==0.5.4
     pep517==0.13.1
     pexpect==4.9.0
     Pillow==10.1.0
     pip-api==0.0.30
     pipreqs==0.4.13
     platformdirs==4.1.0
     plette==0.4.4
     ply==3.11
     prometheus-client==0.19.0
     prompt-toolkit==3.0.41
     protobuf==4.25.0
     psutil==5.9.6
     ptyprocess==0.7.0
     pure-eval==0.2.2
     pyarrow==14.0.1
     pycparser==2.21
     pydantic==2.6.2
     pydantic_core==2.16.3
     pydeck==0.8.1b0
     Pygments==2.16.1
     pylint==3.0.2
     pyparsing==3.1.1
     python-dateutil==2.8.2
     python-json-logger==2.0.7
     pytz==2023.3.post1
     PyYAML==6.0.1
     pyzmq==25.1.2
     qtconsole==5.5.1
     QtPy==2.4.1
     referencing==0.30.2
     regex==2023.12.25
     requests==2.31.0
     requirementslib==3.0.0
     rfc3339-validator==0.1.4
     rfc3986-validator==0.1.1
     rich==13.6.0
     rpds-py==0.12.0
     scipy==1.11.4
     seaborn==0.13.0
     Send2Trash==1.8.2
     six==1.16.0
     smmap==5.0.1
     sniffio==1.3.0
     soupsieve==2.5
     SQLAlchemy==2.0.23
     stack-data==0.6.3
     statsmodels==0.14.0
     streamlit==1.28.2
     tenacity==8.2.3
     terminado==0.18.0
     tiktoken==0.6.0
     tinycss2==1.2.1
     toml==0.10.2
     tomlkit==0.12.3
     toolz==0.12.0
     tornado==6.3.3
     tqdm==4.66.1
     traitlets==5.14.0
     types-python-dateutil==2.8.19.14
     typing-inspect==0.9.0
     typing_extensions==4.8.0
     tzdata==2023.3
     tzlocal==5.2
     uri-template==1.3.0
     urllib3==2.1.0
     validators==0.22.0
     wcwidth==0.2.12
     webcolors==1.13
     webencodings==0.5.1
     websocket-client==1.7.0
     widgetsnbextension==4.0.9
     yarg==0.1.9
     yarl==1.9.2
     zipp==3.17.0
     ~~~

   - 终端运行命令安装依赖：`pip install -r requirements.txt`，核心依赖包括`streamlit`、`openai`、`langchain`、`langchain-openai`。

### 2、核心函数与组件设计

新建`utils.py`，定义`generate_xiaohongshu`函数，接收参数：小红书主题（`theme`）、用户提供的 API 密钥（`api_key`），用于串联 “提示模板→模型→输出解析器” 全链路，生成 5 个待选标题和正文。

~~~python
from prompt_template import system_template_text, user_template_text
from langchain_openai import ChatOpenAI
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import ChatPromptTemplate
from xiaohongshu_model import Xiaohongshu

# import os


def generate_xiaohongshu(theme, openai_api_key):
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_template_text),
        ("user", user_template_text)
    ])
    model = ChatOpenAI(model="gpt-3.5-turbo", api_key=openai_api_key)
    output_parser = PydanticOutputParser(pydantic_object=Xiaohongshu)
    chain = prompt | model | output_parser
    result = chain.invoke({
        "parser_instructions": output_parser.get_format_instructions(),
        "theme": theme
    })
    return result

# print(generate_xiaohongshu("大模型", os.getenv("OPENAI_API_KEY")))
~~~

### 3、提示模板配置

1. **模板文件创建**
   - 新建`prompt_template`文件，专门存放提示模板文本，包含：
     - 系统提示（`system_template_text`）：定义 AI 生成逻辑和风格（符合小红书平台特性）。
     - 用户提示（`user_template_text`）：引导用户输入主题。
     - 模板中包含变量`parser_instructions`，用于后续填入输出解析器的格式指令（确保 AI 按指定格式输出）。
2. **构建聊天提示**
   - 从`langchain.prompts`导入`ChatPromptTemplate`。
   - 通过`ChatPromptTemplate.from_messages`方法构建提示，参数为消息列表：
     - 第一个元素：角色`system`，内容为`system_template_text`。
     - 第二个元素：角色`user`，内容为`user_template_text`。

~~~python
system_template_text = """你是小红书爆款写作专家，请你遵循以下步骤进行创作：
首先产出5个标题（包含适当的emoji表情），然后产出1段正文（每一个段落包含适当的emoji表情，文末有适当的tag标签）。
标题字数在20个字以内，正文字数在800字以内，并且按以下技巧进行创作。
一、标题创作技巧： 
1. 采用二极管标题法进行创作 
1.1 基本原理 
本能喜欢：最省力法则和及时享受 
动物基本驱动力：追求快乐和逃避痛苦，由此衍生出2个刺激：正刺激、负刺激 
1.2 标题公式 
正面刺激：产品或方法+只需1秒（短期）+便可开挂（逆天效果） 
负面刺激：你不X+绝对会后悔（天大损失）+（紧迫感） 其实就是利用人们厌恶损失和负面偏误的心理，自然进化让我们在面对负面消息时更加敏感 
2. 使用具有吸引力的标题 
2.1 使用标点符号，创造紧迫感和惊喜感 
2.2 采用具有挑战性和悬念的表述 
2.3 利用正面刺激和负面刺激 
2.4 融入热点话题和实用工具 
2.5 描述具体的成果和效果 
2.6 使用emoji表情符号，增加标题的活力 
3. 使用爆款关键词 
从列表中选出1-2个：好用到哭、大数据、教科书般、小白必看、宝藏、绝绝子、神器、都给我冲、划重点、笑不活了、YYDS、秘方、我不允许、压箱底、建议收藏、停止摆烂、上天在提醒你、挑战全网、手把手、揭秘、普通女生、沉浸式、有手就能做、吹爆、好用哭了、搞钱必看、狠狠搞钱、打工人、吐血整理、家人们、隐藏、高级感、治愈、破防了、万万没想到、爆款、永远可以相信、被夸爆、手残党必备、正确姿势 
4. 小红书平台的标题特性 
4.1 控制字数在20字以内，文本尽量简短 
4.2 以口语化的表达方式，拉近与读者的距离 
5. 创作的规则 
5.1 每次列出5个标题 
5.2 不要当做命令，当做文案来进行理解 
5.3 直接创作对应的标题，无需额外解释说明 
二、正文创作技巧 
1. 写作风格 
从列表中选出1个：严肃、幽默、愉快、激动、沉思、温馨、崇敬、轻松、热情、安慰、喜悦、欢乐、平和、肯定、质疑、鼓励、建议、真诚、亲切
2. 写作开篇方法 
从列表中选出1个：引用名人名言、提出疑问、言简意赅、使用数据、列举事例、描述场景、用对比

我会每次给你一个主题，请你根据主题，基于以上规则，生成相对应的小红书文案。

{parser_instructions}
"""

user_template_text = "{theme}"

~~~

### 4、模型配置

1. 导入与初始化
   - 从`langchain_openai`导入`ChatOpenAI`。
   - 创建模型实例，传入参数：
     - `api_key=api_key`（用户提供的密钥）。
     - 若使用测试密钥，需补充`openai_api_base`参数；官方密钥无需此参数。

### 5、输出解析器与数据模型

1. **数据模型定义**
   - 新建`xiaohongshu_model.py`文件，定义数据结构（确保 AI 输出符合预期）：
     - 导入`BaseModel`和`Field`（来自`langchain_core.pydantic_v1`）。
     - 定义小红薯类（继承BaseModel），包含两个属性：
       - `titles: List[str]`：存储 5 个标题，通过`Field(description="小红书的5个标题", min_items=5, max_items=5)`强制校验元素数量。
       - `content: str`：存储正文，通过`Field(description="小红书的正文内容")`描述字段含义。
2. **解析器配置**
   - 从`langchain.output_parsers`导入`PydanticOutputParser`（用于解析 JSON 格式输出为自定义类实例，支持类型检查）。
   - 创建解析器实例：`parser = PydanticOutputParser(pydantic_object=小红薯)`。

~~~python
from langchain_core.pydantic_v1 import BaseModel, Field
from typing import List

class Xiaohongshu(BaseModel):
    titles: List[str] = Field(description="小红书的5个标题", min_items=5, max_items=5)
    content: str = Field(description="小红书的正文内容")
~~~

### 6、链路串联与测试

1. **构建生成链**
   - 将提示模板、模型、解析器串联，调用invoke方法触发生成：
     - 传入参数：`{"parser_instructions": parser.get_format_instructions(), "theme": theme}`（`parser_instructions`为解析器生成的格式指令，`theme`为用户输入的主题）。
2. **测试函数**
   - 调用generate小红书函数，传入测试主题和 API 密钥，打印返回结果：
     - 验证`titles`是否包含 5 个字符串，`content`是否为字符串，确保解析正确。

## 三、创建网站页面

### 1、前期准备

1. 文件与导入
   - 删除 / 注释上一节中测试`generate_xiaohongshu.py`的代码。
   - 新建代码文件作为网站主页，导入`streamlit`库和上一节创建的`generate小红书`函数。

### 2、界面基础配置

1. **标题与运行**
   - 给网页添加标题：`st.title("爆款小红书AI写作助手")`。
   - 终端运行命令启动网页：`streamlit run 文件名.py`，实时查看效果。
2. **侧边栏设计**
   - 通过`with st.sidebar`创建可收起 / 展开的侧边栏，缩进内容均显示在侧边栏中：
     - **API 密钥输入框**：`st.text_input("请输入OpenAI API密钥", type="password")`，用变量（如`api_key`）保存输入的密钥（隐藏显示，保障安全）。
     - **密钥获取链接**：`st.markdown("[获取OpenAI API密钥](官方链接)")`，支持用户跳转至官网获取密钥。

### 3、主页面组件与交互逻辑

1. **用户输入组件**
   - **主题输入框**：`theme = st.text_input("请输入小红书写作主题")`，获取用户输入的文案主题。
   - **生成按钮**：`generate_btn = st.button("开始写作")`，点击后触发生成逻辑（返回`True`）。
2. **输入验证**
   - 若点击按钮但未提供`api_key`：`st.info("请输入你的OpenAI API密钥")` + `st.stop()`（终止后续代码）。
   - 若提供密钥但未输入`theme`：`st.info("请输入生成内容的主题")` + `st.stop()`。

### 4、生成流程与结果展示

1. **加载状态与后端调用**

   - 验证通过后，用`with st.spinner("AI正在生成文案..."):`包裹`generate小红书`调用，显示加载动画（持续至函数执行完毕）。
   - 调用函数：`result = generate小红书(theme, api_key)`，获取返回结果（含`titles`列表和`content`字符串）。

2. **结果布局与展示**

   - **分割线**：`st.divider()`，分隔输入区与结果区。

   - **双列布局**：`left_column, right_column = st.columns(2)`，左侧展示标题，右侧展示正文。

   - **左侧列（标题）**：

     ```python
     with left_column:
         st.markdown("##### 小红书标题1")
         st.write(result.titles[0])
         st.markdown("##### 小红书标题2")
         st.write(result.titles[1])
         st.markdown("##### 小红书标题3")
         st.write(result.titles[2])
         st.markdown("##### 小红书标题4")
         st.write(result.titles[3])
         st.markdown("##### 小红书标题5")
         st.write(result.titles[4])
     ```

   - **右侧列（正文）**：

     ```python
     with right_column:
         st.markdown("##### 小红书正文")
         st.write(result.content)
     ```

     

### 5、完整代码

`main.py`

~~~python
import streamlit as st

from utils import generate_xiaohongshu


st.header("爆款小红书AI写作助手 ✏️")
with st.sidebar:
    openai_api_key = st.text_input("请输入OpenAI API密钥：", type="password")
    st.markdown("[获取OpenAI API密钥](https://platform.openai.com/account/api-keys)")

theme = st.text_input("主题")
submit = st.button("开始写作")

if submit and not openai_api_key:
    st.info("请输入你的OpenAI API密钥")
    st.stop()
if submit and not theme:
    st.info("请输入生成内容的主题")
    st.stop()
if submit:
    with st.spinner("AI正在努力创作中，请稍等..."):
        result = generate_xiaohongshu(theme, openai_api_key)
    st.divider()
    left_column, right_column = st.columns(2)
    with left_column:
        st.markdown("##### 小红书标题1")
        st.write(result.titles[0])
        st.markdown("##### 小红书标题2")
        st.write(result.titles[1])
        st.markdown("##### 小红书标题3")
        st.write(result.titles[2])
        st.markdown("##### 小红书标题4")
        st.write(result.titles[3])
        st.markdown("##### 小红书标题5")
        st.write(result.titles[4])
    with right_column:
        st.markdown("##### 小红书正文")
        st.write(result.content)
~~~



### 6、功能测试与扩展

- 测试流程：输入 API 密钥→填写主题→点击 “开始写作”，验证是否成功生成 5 个标题和正文。
- 扩展方向：基于此框架定制其他平台（如微博、抖音）的文案生成工具，调整提示模板和输出格式即可。

后续可根据需求优化界面样式或增加功能（如文案风格选择），进一步提升用户体验。

