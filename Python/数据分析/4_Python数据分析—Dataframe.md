# **Pandas_Dataframe**
### 一、DataFrame简介
相比Series，由多个Series组成的DataFrame，才是我们分析数据是最常打交道的数据结构。

DataFrame看起来像是一个表格，它的不同列可以是不同数据类型，而不是像NumPy二维数组那样，要求数据类型全部保持一致。

相比起Series，DataFrame每个值不止有索引，也有列名。换个角度来看，DataFrame就像是由Series组成的字典，每个Series对应一个键名，也就是列名。

### 二、创建DataFrame 
**创建DataFrame时，会自动进行索引对齐**

#### （一）参数传入一个字典，值是Series
既然DataFrame可以看成由Series组成的字典，那么第一个创建方法就是，参数传入一个字典。键是各个Series所对应的列名。

创建好后，Jupyter Notebook会输出一个，排版好看的DataFrame表格。索引就对应了Series的索引，而列名对应我们传入的键。

参数传入一个字典，值是Series

```python
import pandas as pd
s_id = pd.Series(["01", "02", "03", "04", "05"])
s_class = pd.Series(["二班", "一班", "二班", "三班", "一班"])
s_grade = pd.Series([92, 67, 70, 88, 76])

df1 = pd.DataFrame({"学号": s_id, "班级": s_class, "成绩": s_grade})
df1
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **0** | 01 | 二班 | 92 |
| **1** | 02 | 一班 | 67 |
| **2** | 03 | 二班 | 70 |
| **3** | 04 | 三班 | 88 |
| **4** | 05 | 一班 | 76 |


#### （二）参数传入一个字典，值是列表
```python
l_id = ["01", "02", "03", "04", "05"]
l_class = ["二班", "一班", "二班", "三班", "一班"]
l_grade = [92, 67, 70, 88, 76]

df2 = pd.DataFrame({"学号": s_id, "班级": s_class, "成绩": s_grade})
df2
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **0** | 01 | 二班 | 92 |
| **1** | 02 | 一班 | 67 |
| **2** | 03 | 二班 | 70 |
| **3** | 04 | 三班 | 88 |
| **4** | 05 | 一班 | 76 |


 Dataframe默认的索引和Series一样，都是从0开始依次递增的整数，来表示位置。但如果传入的Series有标签索引的话，DataFrame的索引也会变成相应的标签。    

```python
s_id = pd.Series(["01", "02", "03", "04", "05"], index=["小明", "小红", "小杰", "小丽", "小华"])
s_class = pd.Series(["二班", "一班", "二班", "三班", "一班"], index=["小明", "小红", "小杰", "小丽", "小华"])
s_grade = pd.Series([92, 67, 70, 88, 76],
                    index=["小明", "小红", "小杰", "小丽", "小华"])

df3 = pd.DataFrame({"学号": s_id, "班级": s_class, "成绩": s_grade})
df3
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |
| **小丽** | 04 | 三班 | 88 |
| **小华** | 05 | 一班 | 76 |


#### （三）参数传入一个嵌套字典
参数传入一个嵌套字典，可以一次性创建出既有标签索引，也有列名的DataFrame

 最外层的键仍然对应各个列名，而值则对应每列的Series；里层字典的键对应Series的标签索引

```python
df4 = pd.DataFrame({"学号": {"小明": "01", "小红": "02", "小杰": "03", "小丽": "04", "小华": "05"}, 
                    "班级": {"小明": "二班", "小红": "一班", "小杰": "二班", "小丽": "三班", "小华": "一班"}, 
                    "成绩": {"小明": 92, "小红": 67, "小杰": 70, "小丽": 88, "小华": 76}})
df4
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |
| **小丽** | 04 | 三班 | 88 |
| **小华** | 05 | 一班 | 76 |




### 三、DataFrame的常用属性
#### （一）index属性与columns属性
要获得DataFrame的索引，可以用index属性；要获取所有列名，可以用columns属性。

**返回的索引和列名的数据类型，都是pandas库的Index类**

```python
df4.index

Index(['小明', '小红', '小杰', '小丽', '小华'], dtype='object')

df4.columns

Index(['学号', '班级', '成绩'], dtype='object')
```

#### （二）values属性
要获取所有的值，可以用values属性

返回的类型是NumPy数组，**那所有针对NumPy数组的操作，都可以用在values属性上了**

```python
df4.values

array([['01', '二班', 92],
       ['02', '一班', 67],
       ['03', '二班', 70],
       ['04', '三班', 88],
       ['05', '一班', 76]], dtype=object)
```

#### （三）T属性
对DataFrame进行转置，可以用T属性，**大写的T。**

返回的结果会把行和列进行转置。

```python
df4.T
```

运行结果

|  | **小明** | **小红** | **小杰** | **小丽** | **小华** |
| --- | --- | --- | --- | --- | --- |
| **学号** | 01 | 02 | 03 | 04 | 05 |
| **班级** | 二班 | 一班 | 二班 | 三班 | 一班 |
| **成绩** | 92 | 67 | 70 | 88 | 76 |


获取转置后的属性

```python
df5 = df4.T
print(df5.index)
print(df5.columns)
print(df5.values)
```

运行结果

```python
Index(['学号', '班级', '成绩'], dtype='object')
Index(['小明', '小红', '小杰', '小丽', '小华'], dtype='object')
[['01' '02' '03' '04' '05']
 ['二班' '一班' '二班' '三班' '一班']
 [92 67 70 88 76]]
```

**转置后，索引、列名、值都相应发生了变化**

### 四、从DataFrame中提取数据
#### （一）提取DataFrame的列
##### 1、提取某个列
1)在DataFrame后面跟上方括号，里面放上列名，就能把列名对应的列提取出来。

列的类型是Series，索引对应DataFrame原本的索引。

这就跟我们在Python字典后面跟上方括号，里面放上键名，就能把键对应的值提取出来是类似的

```python
df4['成绩']

小明    92
小红    67
小杰    70
小丽    88
小华    76
Name: 成绩, dtype: int64
```



```python
df4['班级']

小明    二班
小红    一班
小杰    二班
小丽    三班
小华    一班
Name: 班级, dtype: object
```

 2)也可以通过".列名" ，来获取对应的列，因为每列Series其实也是DataFrame的属性

**如果列名里面有空格或特殊符号的话，就不能通过属性名来获取了，只能通过方括号**

**Pandas不允许通过属性来添加/更新列**

```python
df4.成绩

小明    92
小红    67
小杰    70
小丽    88
小华    76
Name: 成绩, dtype: int64
```



```python
df4.班级

小明    二班
小红    一班
小杰    二班
小丽    三班
小华    一班
Name: 班级, dtype: object
```

##### 2、提取任意多列
可以在方括号里放入列表，再在列表里面传入多个列名。

**这样做返回的就不是Series，而是DataFrame了**

```python
df4[["成绩", "班级"]]
```

运行结果

|  | **成绩** | **班级** |
| --- | --- | --- |
| **小明** | 92 | 二班 |
| **小红** | 67 | 一班 |
| **小杰** | 70 | 二班 |
| **小丽** | 88 | 三班 |
| **小华** | 76 | 一班 |


#### （二）提取DataFrame的行
提取列用列名，提取行就应该用索引

##### 1、提取某个行
每行数据是以Series类型进行返回的

1）loc 按照标签索引提取行

2）iloc 按照位置索引提取行

```python
df4.loc["小丽"]

学号    04
班级    三班
成绩    88
Name: 小丽, dtype: object
```

```python
df4.iloc[3]

学号    04
班级    三班
成绩    88
Name: 小丽, dtype: object
```

##### 2、提取部分行
与Series切片类似，给loc标签索引范围，或者给iloc位置索引范围，可以获得多行数据

**标签索引做切片是包含结束值的**

```python
df4.loc["小红": "小丽"]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |
| **小丽** | 04 | 三班 | 88 |




```plain
 df4.iloc[1: 3]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |


##### 3、提取任意多行
可以给loc或iloc后面的方括号里，放入一个列表，里面是想提取出的行的标签或位置索引。与之前提取任意列类似。

```python
df4.loc[["小丽", "小红"]]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小丽** | 04 | 三班 | 88 |
| **小红** | 02 | 一班 | 67 |




```python
df4.iloc[[3, 1]]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小丽** | 04 | 三班 | 88 |
| **小红** | 02 | 一班 | 67 |


#### （三）提取DataFrame的值
##### 1、提取某个DataFrame的元素
可以在loc或iloc后面的方括号里，放上2个参数，第一个表示行，第二个表示列，就能提取出表格某个位置上的值

```python
 df4.loc["小杰", "学号"]

'03'

df4.iloc[2, 0]

'03'
```

##### 2、提取部分DataFrame
提取部分表格数据类似，只需要在loc或iloc后面的方括号里放上2个参数，第一个表示行的切片，第二个表示列的切片，就可以把表格的一部分给切出来

**标签索引做切片会包含结束值**

```python
df4.loc["小红": "小丽", "学号": "成绩"]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |
| **小丽** | 04 | 三班 | 88 |




```python
df4.iloc[1: 3, 0: 2]
```

运行结果

|  | **学号** | **班级** |
| --- | --- | --- |
| **小红** | 02 | 一班 |
| **小杰** | 03 | 二班 |


##### 3、提取部分列，同时保留所有行;提取部分行，同时保留所有列
一个省事的方法是，省略希望保留所有的切片里冒号前后的值，直接放上一个冒号，这能默认表示全部范围的索引 

```python
df4.loc[:, "班级": "成绩"]
```

运行结果

|  | **班级** | **成绩** |
| --- | --- | --- |
| **小明** | 二班 | 92 |
| **小红** | 一班 | 67 |
| **小杰** | 二班 | 70 |
| **小丽** | 三班 | 88 |
| **小华** | 一班 | 76 |




```python
df4.iloc[0: 3, :]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |


##### 4、提取不相邻的行或列
通过往loc或iloc后面的方括号里放入列表，通过标签或位置指明提取哪些

```python
df4.loc[["小红", "小丽"], "学号": "班级"]
```

运行结果

|  | **学号** | **班级** |
| --- | --- | --- |
| **小红** | 02 | 一班 |
| **小丽** | 04 | 三班 |




```python
df4.iloc[[1, 3], 0: 2]
```

运行结果

|  | **学号** | **班级** |
| --- | --- | --- |
| **小红** | 02 | 一班 |
| **小丽** | 04 | 三班 |


### 五、根据条件筛选DataFrame中的行
#### （一）根据条件筛选行，相比于根据条件筛选列来说，是更加常见和合理的。
因为一般每一行代表一个实例，比如一个城市、一个学生，而每一列代表数据实例的属性，比如说城市的人口、学生的身高。那我们筛选符合条件的行，就相当于从已有数据里，提取符合条件的实例，比如人口在1000万以上的城市，身高在1.6米以上的学生。

#### （二）语法
和NumPy的数组以及Pandas的Series是很类似的，在DataFrame后面跟一个方括号，里面放上针对列的条件。列的条件包括：数据类型是Series的列和条件。返回列的两种方法：通过"["列名"]"，或者通过".属性名"，都可以应用在列的条件中。

#### （三）原理
DataFrame的列是Series类型，而Series和条件结合起来，会返回一个布尔值组成的Series,它的长度和DataFrame的行数相对应。DataFrame会用布尔值的Series进行索引，保留True所对应的索引的行。

```python
df4['成绩'] > 80

小明     True
小红    False
小杰    False
小丽     True
小华    False
Name: 成绩, dtype: bool
```



```python
df4[df4["成绩"] > 80]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小丽** | 04 | 三班 | 88 |




```python
df4[df4.成绩 > 80]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小丽** | 04 | 三班 | 88 |


#### （四）结合逻辑运算
条件也可以结合逻辑运算，因为DataFrame有不同列，所以不同条件里，可以根据不同列的变量进行筛选。

```python
df4[(df4.成绩 > 80) & (df4["班级"] == "三班")]
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小丽** | 04 | 三班 | 88 |


### 六、head方法和tail方法
**基本上，对DataFrame的操作方法，都是默认不改变原始DataFrame的，而是返回一个新的DataFrame**

**要操作生效的话，要么就得进行重新赋值，要么指定可选参数inplace=True**

#### （一）head方法
1、DataFrame.head(num)会返回给我们DataFrame前num行的内容，num是可选参数，默认是前5行内容。

2、用处：当我们和实际数据打交道的时候，可能动辄几千、几万甚至几十万数据，这种时候，这个方法就很实用了。可以看一眼开头几行，快速了解数据包含的信息，以及各列里面变量的特点。

```python
df4.head()
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小红** | 02 | 一班 | 67 |
| **小杰** | 03 | 二班 | 70 |
| **小丽** | 04 | 三班 | 88 |
| **小华** | 05 | 一班 | 76 |


增加指定行数

```python
df4.head(2)
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小明** | 01 | 二班 | 92 |
| **小红** | 02 | 一班 | 67 |


#### （二）tail方法
DataFrame.tail(num)会返回给我们DataFrame后num行的内容，num是可选参数，默认是后5行内容

```python
df4.tail(2)
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小丽** | 04 | 三班 | 88 |
| **小华** | 05 | 一班 | 76 |


#### （三）sample方法 
DataFrame.sample(num)会返回给我们DataFrame随机num行的内容，num是可选参数，默认是随机1行内容

```python
df4.sample()
```

运行结果

|  | **学号** | **班级** | **成绩** |
| --- | --- | --- | --- |
| **小华** | 05 | 一班 | 76 |


   
 

